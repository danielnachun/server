--source include/have_partition.inc
--source include/lcase_names.inc
--source suite/parts/inc/engines.inc

# TODO:
#
# DDL log test, binlog test
# Add test cases from EXCHANGE: SP, PS, TRIGGER, GRANT
# Test complex table
# EXTRACT is keyword, now table names cannot be called like that
# LIST partition
# EXTRACT from versioned table must create unversioned table

create or replace table t1 (x int)
partition by hash(x) partitions 2;
--error ER_ONLY_ON_RANGE_LIST_PARTITION
alter table t1 extract partition p1 as table tp1;

create or replace table t1 (x int)
partition by key(x) partitions 2;
--error ER_ONLY_ON_RANGE_LIST_PARTITION
alter table t1 extract partition p1 as table tp1;

create or replace table t1 (x int)
partition by range(x)
subpartition by hash(x) subpartitions 3 (
  partition p1 values less than (10),
  partition pn values less than maxvalue);
--error ER_PARTITION_EXTRACT_SUBPARTITIONED
alter table t1 extract partition p1 as table p1;
--error ER_DROP_PARTITION_NON_EXISTENT
alter table t1 extract partition p1sp0 as table p1;

create or replace table t1 (x int)
partition by range(x) (
  partition p1 values less than (10));
--error ER_DROP_LAST_PARTITION
alter table t1 extract partition p1 as table tp1;

if ($MTR_COMBINATION_RANGE)
{
  create or replace table t1 (x int)
  partition by range(x) (
    partition p1 values less than (10),
    partition p2 values less than (20),
    partition p3 values less than (30),
    partition p4 values less than (40),
    partition p5 values less than (50),
    partition pn values less than maxvalue);
}

if ($MTR_COMBINATION_LIST)
{
  create or replace table t1 (x int)
  partition by list(x) (
    partition p1 values in (2, 3, 4),
    partition p2 values in (12, 13, 14),
    partition p3 values in (22, 23, 24),
    partition p4 values in (32, 33, 34),
    partition p5 values in (42, 43, 44),
    partition pn values in (52, 53, 54));
}

let $all= order by x;

if ($MTR_COMBINATION_HISTORY)
{
  let $all= for system_time all order by x;
  create or replace table t1 (
    x int,
    row_start timestamp(6) as row start invisible,
    row_end timestamp(6) as row end invisible,
    period for system_time(row_start, row_end)
  ) with system versioning
  partition by system_time limit 1 partitions 7;
  alter table t1 drop partition p0;
}

insert into t1 values (2), (12), (22), (32), (42), (52);

if ($MTR_COMBINATION_HISTORY)
{
  delete from t1;
}

create or replace table tp2 (y int);
insert tp2 values (88);
# Multiple ALTER PARTITION statements are not possible
--error ER_PARSE_ERROR
alter table t1 extract partition p2 as table tp2, drop partition p3;
# TODO: probably no need in such specific codes, should be ER_PARTITION_NON_EXISTENT
--error ER_DROP_PARTITION_NON_EXISTENT
alter table t1 extract partition p00 as table tp00;
# Better error here is ER_DROP_PARTITION_NON_EXISTENT,
# but mysql_alter_table() works checks new table before anything else.
# So, looks like no big reason to change anything here.
--error ER_TABLE_EXISTS_ERROR
alter table t1 extract partition p00 as table tp2;
--error ER_TABLE_EXISTS_ERROR
alter table t1 extract partition p2 as table tp2;
select * from tp2;
drop table tp2;
alter table t1 extract partition p2 as table tp2;

--replace_result $engine X ' PAGE_CHECKSUM=1' ''
show create table tp2;
select * from tp2;
--replace_result $engine X ' PAGE_CHECKSUM=1' ''
show create table t1;
eval select * from t1 $all;

--error ER_BAD_DB_ERROR
alter table t1 extract partition p3 as table inexistent.tp3;
create database EXISTENT;
alter table t1 extract partition p3 as table EXISTENT.TP3;

let $tp3= ....none....;
if ($MTR_COMBINATION_LCASE1)
{
  let $tp3= tp3;
}
--replace_result $engine X ' PAGE_CHECKSUM=1' '' $tp3 TP3
show create table EXISTENT.TP3;
select * from EXISTENT.TP3 order by x;
--replace_result $engine X ' PAGE_CHECKSUM=1' ''
show create table t1;
eval select * from t1 $all;

drop database EXISTENT;
drop tables t1, tp2;
